
```{r}

  library(scater)     #main data container
  library(scran)      #zero-inflated normalization by pooling
  library(dropestr)   #UMI correction
  library(SAVER)      #impute dropouts step
  library(doParallel) #required by SAVER
  library(monocle)    #census relative2abs used for "pseudo-spike-ins" normalization
  library(biomaRt)    #genome annotations
  library(M3Drop)     #find DE genes
  library(Seurat)     #unsupervised clustering

  library(VennDiagram)
  library(gplots)

  library(clusterProfiler)#GO analysis stage annotation convertercompatible with ReactomePA
  library(ReactomePA)#GO and GSEA
```


```{r}

types2names <- function(types)
{
  dict <- rep(1, length(unique(types)))
  names(dict) <- unique(types)
  
  cell_names <- NULL
  for (type in types)
  {
    cell_names <- c(cell_names, paste0(type, ".", dict[type]))
    dict[type] <- dict[type] + 1
  }
  return(cell_names)
}

  annot_path <- function(spec)
  {
    if(spec %in% c("h", "human"))
    {
      return("human_cycle.rds")
    }
    if(spec %in% c("m", "mouse"))
    {
      return("mouse_cycle.rds")
    }
  }

  get_genome_annotation_names_mapping <- function(spec, clean = F)
  {
    if (spec %in% c("mouse","m"))
    {
      if(clean&&file.exists(annot_path("m")))
      {
        file.remove(annot_path("m"))
      }
      
      if(file.exists(annot_path("m")))
      {
        anno <- readRDS(annot_path("m"))
      }
      else
      {
        if(testBioCConnection())
        {
          anno <- getBM(attributes=c("ensembl_gene_id", "mgi_symbol", "chromosome_name"), mart=useMart("ensembl", dataset = "mmusculus_gene_ensembl"))
          anno <- list(gene_id = anno$ensembl_gene_id, gene_symbol = anno$mgi_symbol, chr = anno$chromosome_name)
          saveRDS(anno, file = annot_path("m"))
        }
        else
        {
          print("Internet connection required to load annotation for the first time")
          stop()
        }
      }
      
    }
    if (spec %in% c("human","h"))
    { 
      if(clean&&file.exists(annot_path("h")))
      {
        file.remove(annot_path("h"))
      }
      
      if(file.exists(annot_path("h")))
      {
        anno <- readRDS(annot_path("h"))
      }
      else
      {
        if(testBioCConnection())
        {
          anno <- getBM(attributes=c("ensembl_gene_id", "hgnc_symbol", "chromosome_name"), mart=useMart("ensembl", dataset = "hsapiens_gene_ensembl"))
          anno <- list(ensembl_id = anno$ensembl_gene_id, gene_symbol = anno$hgnc_symbol, chr = anno$chromosome_name)
          saveRDS(anno, file = annot_path("h"))
        }
        else
        {
          print("Internet connection required to load annotation for the first time")
          stop()
        }
      }
    }
    return(anno)
  }
 

  detect_genome <- function(gene_names)
  {
    detect_genome_symbol_format <- function(gene_names, annotation)
    {
      symbol = intersect(gene_names, annotation$gene_symbol)
      ensembl = intersect(gene_names, annotation$gene_id)
    
      if(length(symbol) == 0 && length(ensembl) == 0) return (NULL)
      if(length(symbol) > length(ensembl)) return (list(annot = "symbol", genes = symbol))
      else return (list(annot = "ensembl", genes = ensembl))
    }
    
    human <- get_genome_annotation_names_mapping("h")
    mouse <- get_genome_annotation_names_mapping("m")
    
    test_human <- detect_genome_symbol_format(gene_names, human)
    test_mouse <- detect_genome_symbol_format(gene_names, mouse)
    
    if(is.null(test_human)&&is.null(test_mouse))
    {
      print("Gene symbols should be ensembl or gencode. Either mouse or human")
      stop()
    }
    
    if(!is.null(test_human))
    {
      if(is.null(test_mouse) || length(test_mouse$genes) < length(test_human$genes))
      {
        return(list(org = "human", annot = test_human$annot, genes = list(main = test_human$genes, collis = test_mouse$genes)))
      }
    }
    
    if(!is.null(test_mouse))
    {
      if(is.null(test_human) || length(test_mouse$genes) > length(test_human$genes))
      {
        return(list(org = "mouse", annot = test_mouse$annot, genes = list(main = test_mouse$genes, collis = test_human$genes)))
      }
    }
    
    annot = NULL
    if(!is.null(test_mouse)&&!is.null(test_mouse)&&test_mouse$annot == test_human$annot)
    {
      annot = test_mouse$annot
    }
    else
    {
      if(!is.null(test_human)&&is.null(test_mouse))
      {
        annot = test_human$annot
      }
    
      if(!is.null(test_mouse)&&!is.null(test_human))
      {
        annot = test_mouse$annot
      }
    }
    
    return(list(org = NULL, annot = annot, genes = list(main = test_human$genes, collis = test_mouse$genes)))
  }
  
  get_annot_db <- function(gene_names)
  {
    gene_annot <- detect_genome(gene_names)
    db_to_use <- NULL
    if(gene_annot$org %in% c("human", "h"))
    {
      db_to_use <- "org.Hs.eg.db"
    }
    if(gene_annot$org %in% c("mouse", "m"))
    {
      db_to_use <- "org.Mm.eg.db"
    }
    return(db_to_use)
  }

  gene_annot_convert_to <- function(gene_names, new_encoding = "ENTREZID")
  {
    gene_annot <- detect_genome(gene_names)
    old_encoding <- toupper(gene_annot$annot)
    new_encoding <- toupper(new_encoding)
    org_db <- get_annot_db(gene_names)
    if(new_encoding == old_encoding)
    {
      return (list(old = gene_names, new = gene_names))
    }
    gene_annot_mapping <- as.matrix(bitr(gene_names, fromType=old_encoding, toType=new_encoding, OrgDb=org_db))
    return(list(old = gene_annot_mapping[,1], new = gene_annot_mapping[,2]))
  }
  
  mtx_gene_annot_convert_to <- function(mtx, new_encoding = "ENTREZID")
  {
    mtx <- mtx[unique(rownames(mtx)),]
    annot_converted <- gene_annot_convert_to(rownames(mtx), new_encoding = "ENSEMBL")
    names(annot_converted$new) <- NULL

    mtx <- mtx[match(annot_converted$old, rownames(mtx)),]
    rownames(mtx) <- annot_converted$new
    
    mtx <- mtx[unique(rownames(mtx)),]
    
    return(mtx)
  }
  
```

```{r}
  
  # presort matrix by decreasing sum of row and columns
  # can be usefull to select top-N expressed genes
  sort_by_rowcol_sum <- function(A)
  {
    gene_sum = rowSums(A)
    cell_sum = c(colSums(A),0)
    
    B <-cbind(A, gene_sum)
    B <-rbind(B, cell_sum)
    
    genes_ordered = order(B[,"gene_sum"], decreasing = TRUE)
    cells_ordered = order(B["cell_sum",], decreasing = TRUE)
    
    B <- B[genes_ordered, cells_ordered]
    
    sorted <- B[-grep("cell_sum", rownames(B)), -grep("gene_sum", colnames(B))]
    return (sorted[rowSums(sorted)>0, colSums(sorted)>0])
  }
  
  rel2abs <- function(mtx)
  {
    fd <- as.matrix(rownames(mtx))
    rownames(fd) <- fd
    colnames(fd)[1]<-"gene_short_name"
    
    
    pd <- as.matrix(colnames(mtx))
    rownames(pd) <- pd
    colnames(pd)[1]<-"cell_name"
    
    pd <- new("AnnotatedDataFrame", data = as.data.frame(pd))
    fd <- new("AnnotatedDataFrame", data = as.data.frame(fd))
    
    relative <- newCellDataSet(as.matrix(mtx),
                               phenoData = pd,
                               featureData = fd,
                               lowerDetectionLimit = 0.1,
                               expressionFamily = tobit(Lower = 0.1))
    
    rpc_matrix <- sort_by_rowcol_sum(na.omit(t(na.omit(t(relative2abs(relative, t_estimate = estimate_t(exprs(relative)), method = "num_genes", cores = cores))))))
    
    return (rpc_matrix)
  }
  
  saver_impute <-function(expr, size_factors = NULL, genes = NULL, cores = parallel:::detectCores()-1)
  {
    expr_new <- sort_by_rowcol_sum(t(na.omit(t(na.omit(expr)))))
    if(is.null(genes))
    {
      genes <- rownames(expr_new)
      if(nrow(expr_new)>3000)
      {
        genes <- genes[1:3000]
      }
    }
    
    doParallel::stopImplicitCluster()
    doParallel::registerDoParallel(cores = cores)
    
    max_var <- nrow(expr_new) 
    
    if(is.null(size_factors))
    {
      impute_sorted_in <- saver(expr_new,
                              parallel = T, 
                              pred.genes = which(rownames(expr_new) %in% genes), 
                              nzero = max(10, ncol(expr_new)/20), 
                              dfmax = 5 #limit netglm model complexity to speed-up computations
                                         #should not affect result too much, cuz every gene processed separately in SAVER
                              )
    }
    else
    {
      impute_sorted_in <- saver(expr_new,
                              parallel = T, 
                              size.factor = size_factors, 
                              pred.genes = which(rownames(expr_new) %in% genes), 
                              nzero = max(10, ncol(expr_new)/20),
                              dfmax = 5
                              )
    }
    
    doParallel::stopImplicitCluster()
    
    rpc_matrix_new <- t(na.omit(t(impute_sorted_in$estimate)))
    
    return (rpc_matrix_new)
  }
  
  matrix_sum <- function(A, B)
    {
      A[rownames(B), colnames(B)] <- A[rownames(B), colnames(B)] + B[rownames(B), colnames(B)]
      return (A)
    }
  
  load_velocity_mtx <- function(path)
  {
    # Merge matrix of intron-exon matrix counts by gene name
    
    dropestOutput <- readRDS(path)


    exo_mtx <- as.matrix(dropestOutput$exon)
    intro_mtx <- as.matrix(dropestOutput$intron)
    span_mtx <- as.matrix(dropestOutput$spanning)

    detected_genes <- unique(c(rownames(exo_mtx), rownames(intro_mtx), rownames(span_mtx)))
    cells_count <- ncol(exo_mtx)
    expr_all <- matrix(0, nrow = length(detected_genes), ncol = cells_count)
    
    rownames(expr_all) <- detected_genes
    colnames(expr_all) <- colnames(exo_mtx)

    expr_all <- matrix_sum(expr_all, exo_mtx)
    expr_all <- matrix_sum(expr_all, intro_mtx)
    expr_all <- matrix_sum(expr_all, span_mtx)
    
    return(expr_all)
  }
  
  norm_levels <- function(sce)
  {
    min_l <- max(2, ncol(sce)/100)
    max_l <- min(ncol(sce)/10, 100)
    return (seq(min_l, max_l, (max_l - min_l)/10))
  }
  
  sce_norm <- function (mtx)
  {
    filter_simple <- function(sce)
    {
      #Simple quality control on the cells
      keep_feature <- rowSums(counts(sce) > 0) > 0
      sce <- sce[keep_feature,]
    
      numcells <- nexprs(sce, lowerDetectionLimit = 1, byrow=T)
      keep.gene <- numcells >= 2
    
      numgenes <- nexprs(sce, lowerDetectionLimit = 1, byrow=F)
      keep.cell <- numgenes >= 50
    
      sce <- sce[keep.gene, keep.cell]
      return(sce)
    }
    
    sce_temp <- SingleCellExperiment(assays = list(counts = mtx))
    sce_temp <- filter_simple(sce_temp)

    sce_temp <- computeSumFactors(sce_temp, sizes=norm_levels(sce_temp), positive = F)
    summary(sizeFactors(sce_temp))
    sce_temp<-normalize(sce_temp)
    return (sce_temp)
  }
  
  magic_impute <- function (imputed_genes, components = 100)
  {
      magicimpute2matrix<-function(M)
    {
      B <- data.frame(M)
      colnames(B) <- colnames(M)
      rownames(B) <- M[,"X"]
      B <- t(as.matrix(B[,which(colnames(M)!="X")]))
      storage.mode(B) <- "numeric"
      return (B)
    }
    
    write.csv(imputed_genes, file = "for_magic_exprs.csv")
  
    system(paste0('bash -c "MAGIC.py -d for_magic_exprs.csv -o magic_out.csv  --cell-axis \'columns\' -n -p ', components,' csv"'))

    magic_imputed <- read.csv(file = "magic_out.csv")
  
    magic_imputed <- magicimpute2matrix(magic_imputed)
  
    unlink("for_magic_exprs.csv")
    unlink("magic_out.csv")

    return (na.omit(magic_imputed))
  }
  
  
  detect_DE_genes <- function(mtx)
  {
    Normalized_data <- M3DropCleanData(mtx,
                   labels = colnames(mtx),
                   is.counts=TRUE)

    M3Drop_genes <- M3DropGetExtremes(Normalized_data$data, fdr_threshold=0.05)

    DE_genes <- NULL
    for(method in c("holm", "hochberg", "hommel", "bonferroni", "BH", "BY", "fdr"))
    {
      DE_genes <- c(DE_genes, rownames(M3DropDifferentialExpression(Normalized_data$data,
                         mt_method=method, mt_threshold=0.05, suppress.plot = T)))
    }

    DE_genes <- unique(DE_genes, c(M3Drop_genes$left, M3Drop_genes$right))
  
    seurat_temp <- CreateSeuratObject(raw.data = mtx, min.cells = 3, min.genes = 200)
    seurat_temp <- NormalizeData(object = seurat_temp, normalization.method = "LogNormalize")
    seurat_temp <- FindVariableGenes(object = seurat_temp, mean.function = ExpMean, dispersion.function = LogVMR)
    
    DE_genes <- unique(c(seurat_temp@var.genes, DE_genes))
    
    DE_genes <- DE_genes[order(rowSums(mtx[DE_genes,]), decreasing = T)]
    
    return(DE_genes)
  }
  

  
  simple_preprocessing <- function(sce, libsize = T, feature = F, mito = T, spikeIns = T)
  {
    
    filter_mito <- function (sce)
    {
      #MT QC
      detected_genome <- detect_genome(rownames(sce))
      anno <- get_genome_annotation_names_mapping(detected_genome$org)
      #Filter unknown genes
      is.mito <-  rownames(sce) %in% anno$gene_symbol[which(anno$chr == "MT")]
    
      is.mito_offline<-grepl("^mt-", rownames(sce))
    
      if((exists("is.mito")&&length(which(is.mito))==0)||(!exists("is.mito")))
      {
          is.mito <- is.mito_offline
      }
      return(rownames(sce)[which(is.mito)])
    }
    
    filter_spikeIns <- function(sce)
    {
      is.spike <- (grepl("^ERCC-", rownames(sce)) | grepl("^ercc-", rownames(sce)))
      isSpike(sce, "ercc") <- is.spike
      return(rownames(sce)[which(is.spike)])
    }

    sce <- calculateQCMetrics(sce, exprs_values = "counts", feature_controls = list(mt = filter_mito(sce), ercc = filter_spikeIns(sce)),
                            cell_controls = NULL, nmads = 3, pct_feature_controls_threshold = 80)
  
    final_drop <- rep(F, ncol(sce))
    
    libsize.drop <- rep(F, ncol(sce))
    if(libsize) {
      libsize.drop <- isOutlier(sce$total_counts, nmads=3, type="low", log=FALSE)
      final_drop <- libsize.drop|final_drop
      }
    
    feature.drop <- rep(F, ncol(sce))
    if(feature) {
      feature.drop <- isOutlier(sce$total_features, nmads=3, type="low", log=FALSE)
      final_drop <- feature.drop|final_drop
      }
    
    mito.drop <- rep(F, ncol(sce))
    if(mito) {
      mito.drop <- isOutlier(sce$total_counts_mt, nmads=3, type="high")
      final_drop <- mito.drop|final_drop
      }
    
    spike.drop <- rep(F, ncol(sce))
    if(spikeIns) {
      spike.drop <- isOutlier(sce$total_counts_ercc, nmads=3, type="both")
      final_drop <- spike.drop|final_drop
      }
    
    sce <- sce[,!final_drop]
    data.frame(ByLibSize=sum(libsize.drop), ByFeature=sum(feature.drop),
               ByMito=sum(mito.drop), BySpike=sum(spike.drop), Remaining=ncol(sce))
    
    #Computing separate size factors for spike-in transcripts if exists
    sce1 <- tryCatch(computeSpikeFactors(sce, type="ercc", general.use=FALSE), error = function(e) {})
    if(!is.null(sce1))
    {
      sce <- sce1
    }
  
    #Deconvolution method to normalize genes with lots of zero-counts
    sce <- computeSumFactors(sce, sizes=norm_levels(sce), positive = F)
    summary(sizeFactors(sce))
    sce <- normalise(sce)
    
    return(sce)
  }
  
  cell_cycle_markers <- function(org)
  {
    pairs = NULL
    if(org %in% c("human", "h"))
    {
      pairs <- readRDS(system.file("exdata", "human_cycle_markers.rds", package="scran"))
    }
      
    if(org %in% c("mouse", "m"))
    {
      pairs <- readRDS(system.file("exdata", "mouse_cycle_markers.rds", package="scran"))
    }
    
    return(pairs)
  }
  
  cell_cycle_decomposed_normalization <- function(sce)
  {
    cyclone_mapping <- function(sce, org, annot)
    {
      annot_map <- get_genome_annotation_names_mapping(spec = org)
      if(annot == "ensembl")
      {
        ensembl <- annot_map$gene_id[match(rownames(sce), annot_map$gene_id)]
      }
      
      if(annot == "symbol")
      {
        ensembl <- annot_map$gene_id[match(rownames(sce), annot_map$gene_symbol)]
      }
      
      assignments <- cyclone(sce, cell_cycle_markers(org), gene.names=ensembl)
      return (assignments)
    }
    
    detected_genome <- detect_genome(rownames(sce))
    if(is.null(detected_genome$org) || is.null(detected_genome$annot))
    {
      print("Unable to deside which organism to work with, skipping cell_cycle_decomposition step")
    } else
    {
      assignments <- cyclone_mapping(sce, detected_genome$org, detected_genome$annot)
      
      sce_g1 <- sce[,which(assignments$normalized.scores$G1 >= 0.5)]
      sce_g2m <- sce[,which(assignments$normalized.scores$G2M >= 0.5)]
      sce_s <- sce[,which(assignments$normalized.scores$S >= 0.5)]
      
      return(list(G1 = simple_preprocessing(sce_g1), G2M = simple_preprocessing(sce_g2m), S = simple_preprocessing(sce_s)))
    }
    
    return(NULL)
  }
  
    saver_three_path_impute <- function(sce)
    {
      #detection of highly variable genes to reduce impute step required time
      #combine several methods to get best result after impute step
    
      DE_genes <- detect_DE_genes(2^exprs(sce)-1)
      
      DE_genes_magic0 <- DE_genes[seq(1, length(DE_genes),3)]
      length(DE_genes_magic0)
      imputed_genes0 <- saver_impute(counts(sce), size_factors = sizeFactors(sce), genes = DE_genes_magic0)
      
      DE_genes_magic1 <- DE_genes[seq(2, length(DE_genes),3)]
      length(DE_genes_magic1)
      imputed_genes1 <- saver_impute(counts(sce), size_factors = sizeFactors(sce), genes = DE_genes_magic1)
      
      DE_genes_magic2 <- DE_genes[seq(3, length(DE_genes),3)]
      length(DE_genes_magic2)
      imputed_genes2 <- saver_impute(counts(sce), size_factors = sizeFactors(sce), genes = DE_genes_magic2)
      
      
      return(list(x = rel2abs(imputed_genes0), y = rel2abs(imputed_genes1), z = rel2abs(imputed_genes2)))
    }

  
full_preprocess <- function(working_path = NULL, counts_mtx = NULL, consider_cell_cycle = T, impute = F, markers = NULL, clean = FALSE)
{
  print("Loading data...")
  
  dir.create(working_path, showWarnings = FALSE)
  setwd(working_path)
  if(clean)
  {
    unlink("expression_final.rds")
  }
  
  # Reuse final results if already computed
  if(file.exists("expression_final.rds"))
  {
    expr_out<-readRDS(file = "expression_final.rds")
    return (expr_out)
  }
    
  #load data
  if(is.null(counts_mtx))
  {
    expr_all <- load_velocity_mtx(paste(working_path,"cell.counts.matrices.rds", sep = ""))
    
  }else
  {
    expr_all <- counts_mtx
  }


  #umi_corrected <- dropestr:: CorrectUmiSequenceErrors(reads_per_umi_per_cell, mc.cores=1, verbosity.level=2) 
  
  sce <- sce_norm(expr_all)
  print("Simple preprocessing...")
  sce <- simple_preprocessing(sce)
  dim(sce)
   
  #cell_cycle_decomposition currently has no effect without impute step 
  if(!impute)
  {
    return(2^rel2abs(exprs(sce))-1)
  }
  print("Cell cycle based classification...")
  sce_cycled <- NULL
  if(consider_cell_cycle)
  {
    sce_cycled <- tryCatch(cell_cycle_decomposed_normalization(sce), error = function(e) {})
  }
  
  print("Imputing dropouts...")
  if(!is.null(sce_cycled))
  {
    lapply(sce_cycled, dim)
    if(impute)
    {
      sce_saver <- lapply(sce_cycled, saver_three_path_impute)
    }else{
      sce_saver <- lapply(sce_cycled, function(sce_set){return(2^rel2abs(exprs(sce_set)))-1})
    }
  }
  else
  {
    if(impute)
    {
      sce_saver <- saver_three_path_impute(sce)
    }else{
      sce_saver <- 2^rel2abs(exprs(sce))-1
    }
  }
  
  print("Done...")
  saveRDS(sce_saver, file = "expression_final.rds")
  return(sce_saver)
}
```


```{r}
  add_zero_genes <- function (mtx, gene_list)
  {
    new_extent <- matrix(0L, nrow = length(gene_list), ncol = ncol(mtx))
    rownames(new_extent) <- gene_list
    mtx <- rbind(mtx, new_extent)
    return(mtx[order(rownames(mtx)),])
  }

  m_bind <- function(A, B, lA = "", lB = "", lAe = "", lBe = "")
  { 
    genes_all <- unique(c(rownames(A), rownames(B)))
    
    genes_zero_A <- setdiff(genes_all, rownames(A))
    A <- add_zero_genes(A, genes_zero_A)
    colnames(A) <- sapply(1:ncol(A), function(x) {return(paste0(lA, unlist(strsplit(colnames(A)[x], ".", fixed = TRUE))[1], lAe, ".", x))})
    
    genes_zero_B <- setdiff(genes_all, rownames(B))
    B <- add_zero_genes(B, genes_zero_B)
    colnames(B) <- sapply(1:ncol(B), function(x) {return(paste0(lB, unlist(strsplit(colnames(B)[x], ".", fixed = TRUE))[1], lBe, ".", x))})
    
    C <- cbind(A[order(rownames(A)),], B[order(rownames(B)),])
    
    return (C)
  }
```


```{r}
get_types <- function(arr)
{
  return(sapply(arr, function(cell) { return(unlist(strsplit(cell, ".", fixed = TRUE))[1])}))
}


dub <- function(dataset_ex, copy_times = 0)
{
  dataset_copy <- dataset_ex
  temp_names <- colnames(dataset_ex)
  if(copy_times==0 || copy_times==1)
  {
     return(dataset_ex)
  }
  
  for (i in 1:(copy_times-1))
  {
    colnames(dataset_copy) <- sapply(temp_names, function(cell) { return(paste0(cell,".copy",i))})
    dataset_ex <- cbind(dataset_ex, dataset_copy)
  }
  return(dataset_ex)
}

get_cell_names_by_ident <- function(seur, clusters)
{
  ident <- get_ident(seur)
  
  return(names(ident)[which(ident%in%clusters)])
}

get_ident <- function(seur, types = NULL)
{
  ident <- seur@ident[which(!grepl(".copy", names(seur@ident)))]
  
  if(!is.null(types))
  {
    return(ident[which(get_types(names(ident))%in%types)])
  }
  return(ident)
} 

get_orig_ident <- function(seur, types = NULL)
{
  ident <- seur@meta.data$orig.ident[which(!grepl(".copy", names(seur@ident)))]
  
  if(!is.null(types))
  {
    return(ident[which(get_types(names(ident))%in%types)])
  }
  return(ident)
} 

```

```{r}


merge_saver_split <- function(saver_splited, lA = ".x", lB = ".y", lC = ".z")
{
  A <- rel2abs(saver_splited$x)
  B <- rel2abs(saver_splited$y)
  C <- rel2abs(saver_splited$z)
    
  genes_all <- unique(c(rownames(A), rownames(B), rownames(C)))
      
  genes_zero_A <- setdiff(genes_all, rownames(A))
  A <- add_zero_genes(A, genes_zero_A)
  colnames(A) <- sapply(1:ncol(A), function(x) {return(paste0(unlist(strsplit(colnames(A)[x], ".", fixed = TRUE))[1], lA, ".", x))})
    
  genes_zero_B <- setdiff(genes_all, rownames(B))
  B <- add_zero_genes(B, genes_zero_B)
  colnames(B) <- sapply(1:ncol(B), function(x) {return(paste0(unlist(strsplit(colnames(B)[x], ".", fixed = TRUE))[1], lB, ".", x))})
      
  genes_zero_C <- setdiff(genes_all, rownames(C))
  C <- add_zero_genes(C, genes_zero_C)
  colnames(C) <- sapply(1:ncol(C), function(x) {return(paste0(unlist(strsplit(colnames(C)[x], ".", fixed = TRUE))[1], lC, ".", x))})
 
        
  E <- cbind(A[order(rownames(A)),], B[order(rownames(B)),], C[order(rownames(C)),])

  return (E)
}

merge_cycle <- function(cycle_splited, lA = ".g1", lB = ".g2m", lC = ".s")
{
  if("x" %in% names(cycle_splited$G1))
  {
    A <- merge_saver_split(cycle_splited$G1)
    B <- merge_saver_split(cycle_splited$G2M)
    C <- merge_saver_split(cycle_splited$S)
  }else{
    A <- cycle_splited$G1
    B <- cycle_splited$G2M
    C <- cycle_splited$S
  }
  genes_all <- unique(c(rownames(A), rownames(B), rownames(C)))
    
  genes_zero_A <- setdiff(genes_all, rownames(A))
  A <- add_zero_genes(A, genes_zero_A)
  colnames(A) <- sapply(1:ncol(A), function(x) {return(paste0(unlist(strsplit(colnames(A)[x], ".", fixed = TRUE))[1], lA, ".", x))})
    
  genes_zero_B <- setdiff(genes_all, rownames(B))
  B <- add_zero_genes(B, genes_zero_B)
  colnames(B) <- sapply(1:ncol(B), function(x) {return(paste0(unlist(strsplit(colnames(B)[x], ".", fixed = TRUE))[1], lB, ".", x))})
  
  genes_zero_C <- setdiff(genes_all, rownames(C))
  C <- add_zero_genes(C, genes_zero_C)
  colnames(C) <- sapply(1:ncol(C), function(x) {return(paste0(unlist(strsplit(colnames(C)[x], ".", fixed = TRUE))[1], lC, ".", x))})
    
  E <- cbind(A[order(rownames(A)),], B[order(rownames(B)),], C[order(rownames(C)),])
  return(E)
}

merge_splits <- function(splits)
{
  if("G1" %in% names(splits) && !is.null(splits$G1))
  {
    return(as(merge_cycle(splits), "dgCMatrix"))
  }
  if("x" %in% names(splits) &&!is.null(splits$x))
  {
    return(as(merge_saver_split(splits), "dgCMatrix"))
  }
  return(rel2abs(splits))
}


```


```{r}
seurat_analyse <- function(mtx, regress = T, regress_cc_diff = F)
{
  seur <- CreateSeuratObject(raw.data = mtx)
  seur@meta.data[, "orig.ident"] <- get_types(colnames(seur@raw.data))
    
  seur <- NormalizeData(object = seur, normalization.method = "LogNormalize")
  seur <- FindVariableGenes(object = seur, do.plot = F)
    
  if(regress)
  {
    genome <- detect_genome(rownames(seur@raw.data))
    cc <- cell_cycle_markers(genome$org)
    G2M <- gene_annot_convert_to(unique(cc$G2M$first), genome$annot)$new
    S <- gene_annot_convert_to(unique(cc$S$first), genome$annot)$new
    seur1 <- tryCatch(CellCycleScoring(seur, G2M, S, set.ident = F), error = function(e) {})
    
    if(!is.null(seur1))
    {
      seur<-seur1
      if(regress_cc_diff)
      {
        seur@meta.data$CC.Difference <- seur@meta.data$S.Score - seur@meta.data$G2M.Score
        seur <- ScaleData(object = seur, vars.to.regress = c("nUMI", "CC.Difference"), display.progress = T)
      }
      else{
        seur <- ScaleData(object = seur, vars.to.regress = c("nUMI", "S.Score", "G2M.Score"), display.progress = T)
      }
    }else{
      seur <- ScaleData(object = seur, vars.to.regress = c("nUMI"), display.progress = T)
    }
  }else{
    seur <- ScaleData(object = seur)
  }
  
  seur <- RunPCA(object = seur, do.print = FALSE, pcs.print = NULL, genes.print = NULL)
  seur <- ProjectPCA(object = seur, do.print = FALSE)
  
  for(perplex in seq(300, 5,-5))
  {
    seur1 <- tryCatch(RunTSNE(object = seur, dim.embed = 2, check_duplicates = FALSE, perplexity = perplex),error = function(e) {})
    if(!is.null(seur1))
    {
      print(paste0("perplex ", perplex))
      seur <- seur1
      break
    }
  }
  
  
  for(rez in seq(0.1, 0.9, 0.1))
  {
    seur <- FindClusters(object = seur, resolution = rez, algorithm = 3, modularity.fxn = 1, print.output = F, save.SNN = T)
    if(length(table(seur@ident))>1)
    {
      print(paste0("rez ", rez))
      break
    }
  }
  
  return (seur)
}

get_copy_count <- function(seur)
{
  first_split <- sapply(colnames(seur@raw.data), function(cell) { return(unlist(strsplit(cell, ".copy", fixed = TRUE))[2])})
  mult <- max(as.numeric(first_split[which(!is.na(first_split))]))+1
  if(is.infinite(mult))
  {
    mult <- 1
  }
  return(mult)
}

seur_find_multiplication <- function(seur, cluster = NULL, gran_shresh = 3, ...)
{
  curr_mult <- NULL
  if(is.null(cluster))
  {
    raw_data <- seur@raw.data
    curr_mult <- 1
  }else{
    raw_data <- seur@raw.data[, get_cell_names_by_ident(seur, cluster)]
    curr_mult <- get_copy_count(seur)+1
  }
  
  for(mult in seq(curr_mult, 20, 2))
  {
    print(paste0("mult ", mult))
    seur_mult <- tryCatch(seurat_analyse(dub(raw_data, 1), ...),error = function(e) {print(e)})
    if(!is.null(seur_mult))
    {
      if(length(which(table(get_ident(seur_mult))>gran_shresh))>1)
      {
        return(seur_mult)
      }
    }
  }
  return(NULL)
}

plot_tsn <- function(seur)
{
    p1 <- TSNEPlot(object = seur, group.by = "orig.ident", do.return = TRUE, pt.size = 1.5)
    p2 <- TSNEPlot(object = seur, do.return = TRUE, pt.size = 1.5)
    plot_grid(p1, p2)
}

plot_pca <- function(seur)
{
  p1 <- PCAPlot(object = seur, group.by = "orig.ident", dim.1 = 1, dim.2 = 2, do.return = TRUE, pt.size = 1.5)
  p2 <- PCAPlot(object = seur, do.return = TRUE, dim.1 = 1, dim.2 = 2, pt.size = 1.5)
  plot_grid(p1, p2)
}



```


```{r}

plot_venn <- function(cl_markers)
{
  VENN.LIST <- cl_markers$cluster.markers.list[1:min(5, length(cl_markers$cluster.markers))]
  VENN.LIST <- lapply(VENN.LIST, sort)

  names(VENN.LIST) <- (1:min(5, length(cl_markers$cluster.markers)))-1
  grid.newpage()
  venn.plot <- venn.diagram(VENN.LIST, NULL, fill=rainbow(length(names(VENN.LIST))), 
                             alpha=rep(0.5,length(names(VENN.LIST))), cex = 2, cat.fontface=4, 
                             category.names=names(VENN.LIST), main="DE Genes Inters")
 
  grid.draw(venn.plot)
}

find_markers <- function(curr_seur, p_val = 0.05, ...)
{
  cluster.markers <- NULL
  cluster_numbers <- NULL
  for (ident in sort(unique(curr_seur@ident)))
  {
    curr_len  <- length(cluster.markers)
    
    try(cluster.markers <- c(cluster.markers, list(ident = FindMarkers(object = curr_seur, ident.1 = ident, ...))))
  }
  
  #filter by p_val
  for (i in 1:length(cluster.markers))
  {
    if(length(cluster.markers[i]$ident)==0){ next }
    
    cluster.markers[i]$ident <- cluster.markers[i]$ident[which(cluster.markers[i]$ident$p_val_adj<=p_val),]
    
  }
  
  
  cluster.markers.list <- NULL
  for (i in 1:length(cluster.markers))
  {
    if(length(cluster.markers[i]$ident)==0){
      cluster.markers.list <- c(cluster.markers.list, list(item = list()))
      next }
    
    entrez_converted <- gene_annot_convert_to(rownames(cluster.markers[i]$ident))
    names(entrez_converted$new) <- NULL
    
    cluster.markers[i]$ident <- cluster.markers[i]$ident[match(entrez_converted$old, rownames(cluster.markers[i]$ident)),]
    cluster.markers[i]$ident <- cluster.markers[i]$ident[order(cluster.markers[i]$ident$avg_logFC, decreasing = T),]
    
    
    cluster.markers.list <- c(cluster.markers.list, list(item = entrez_converted$new))
  }
  cl_markers <- list(cluster.markers = cluster.markers, cluster.markers.list = cluster.markers.list)
  
  return(cl_markers)
}

GO_enr <- function(cl_markers, p_val = 0.05, q_val = 0.05, new_window = T)
{
  new_window = T
  
  cluster.markers <- cl_markers$cluster.markers
  cluster.markers.list <- cl_markers$cluster.markers.list
  
  names(cluster.markers.list) <- rep("item", length(cluster.markers.list))
  for (i in 1:length(cluster.markers.list))
  {
    cl_mark <- cluster.markers.list[i]$item
    
    x <- enrichGO(gene=cl_mark, pvalueCutoff=0.05, qvalueCutoff = 0.05, readable=T, OrgDb = get_annot_db(rownames(cluster.markers$ident)))
    x@result$Description[order(x@result$GeneRatio,decreasing = T)]
    enrichMap(x, layout=igraph::layout_components, vertex.label.cex = 1, fixed = !new_window)
    
    cnetplot(x, categorySize="GeneRatio", fixed = !new_window)
  }
  names(cluster.markers.list) <-  sapply(1:length(cluster.markers.list), function(cl){return(paste0("X",cl-1))})
  res <- compareCluster(cluster.markers.list, fun="enrichGO", OrgDb = get_annot_db(rownames(cluster.markers$ident)))
  plot(res, showCategory=20)
}

```

```{r}
plot_seur_3d <- function(seurat_datset)
{
  library(plyr)
  library(scatterplot3d)
  library(rgl)
  
  merge_embed <- function(M)
  {
    resi <- function(l)
    {
      return(plotrix::rescale(l, c(0,1)))
    }
    
    embed <- resi(M[,1])
    for(i in 2:ncol(M))
    {
      temp <- resi(M[,i-1])
      embed <- embed + (abs(min(temp))+abs(max(temp)))*resi(M[,i])
    }
    return(embed)
  }


    seurat_datset <- RunTSNE(object = seurat_datset, check_duplicates = FALSE, dim.embed = 3)
    
    rl <- cbind(
      seurat_datset@dr$tsne@cell.embeddings[,1],
      seurat_datset@dr$tsne@cell.embeddings[,2],
      seurat_datset@dr$tsne@cell.embeddings[,3]
    )


  curr_labels <- seurat_datset@ident
  cells_lab <- unique(curr_labels)
  labels_uniq <- data.frame(names = cells_lab, colors =  rainbow(length(cells_lab)))

  mfrow3d(1, 2)
  next3d()
  plot3d(x = rl[,1], y = rl[,2], z = rl[,3], col = mapvalues(curr_labels, from = array(labels_uniq$names), to = array(labels_uniq$colors)), type="s", radius=1)
  legend3d("topright", col = array(labels_uniq$colors), legend=labels_uniq$names, cex=3, pch = 20)
  next3d()

  curr_labels <- seurat_datset@meta.data$orig.ident
  cells_lab <- unique(curr_labels)
  labels_uniq <- data.frame(names = cells_lab, colors =  rainbow(length(cells_lab)))

  plot3d(x = rl[,1], y = rl[,2], z = rl[,3], col = mapvalues(curr_labels, from = array(labels_uniq$names), to = array(labels_uniq$colors)), type="s", radius=1)
  legend3d("topright", col = array(labels_uniq$colors), legend=labels_uniq$names, cex=3, pch = 20)  

}
```
